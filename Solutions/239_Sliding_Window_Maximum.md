## 1. 时间复杂度: O(kn) 空间复杂度: O(1)
这个和`239`是同一个题
### 方法
遍历数组中的每个滑动窗口，共有`nums.size() - k + 1`个，对于每个滑动窗口，找出其中`k`个元素的最大值
### 代码
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if (nums.empty()) return {};
        int max_tmp;
        vector<int> ans(nums.size() - k + 1);
        for (int i = 0; i < nums.size() - k + 1; ++i) {
            max_tmp = nums[i];
            for (int j = i + 1; j < i + k; ++j) {
                max_tmp = max(max_tmp, nums[j]);
            }
            ans[i] = max_tmp;
        }
        return ans;
    }
};
```
### 结果
![method 1](./results/Offer59-I-1.png)
### 缺点
没有利用相邻滑动窗口之间重叠部分的信息


## 2. 时间复杂度: O(n) 空间复杂度: O(n)
### 方法
使用单调队列模拟滑动窗口以减少时间复杂度。
单调队列是基于双端队列的，队首和队尾均可弹出，只有队尾可以添加。
假定该单调先队列为队尾到队首依次递增，即队首最大，队尾最小。

#### 添加操作：
只有在滑动窗口移到位置时才进行添加操作。
如果队首的值为该队列中的最大值，当新元素要入队时，为了维持单调性，需要弹出队列中比新元素小的值。
这种行为的解释是，我们知道在滑动窗口中，新来的元素肯定在滑动窗口中存在的时间要长一些，而且他的值又比那些之前存在的元素要大，那么就没理要保存那些之前就存在的还小的元素了。类似的，如果当前添加的元素比之前队列的元素小，那么就仗着自己还年轻，老老实实呆在后面，期待着等把前面的大哥都送走了，自己有可能就是老大了。

#### 删除操作：
正如定义中的，队尾和队首均可删除。队尾删除的情况已经在上面讨论过了。接下来解释队首的删除情况：
首先明确，优先队列相当于另开辟了一个空间，优先队列中元素的顺序和原数组没有关系。
当队列中最大的是该滑动窗口中的第一个值时，需要在队列中弹出该值。
这种行为的解释是，在滑动窗口移到下一个位置后，这个值就不会存在滑动窗口中了。（虽然你很强，但是时间面前，人人平等）

#### 注意：
最开始写代码的时候我是只要把之前队列内相同值的元素也删了，报错了。

思考：错误的case是，在同一个滑动窗口中，出现了两个相同的最大值，这个时候本来应该是弹出存在时间长的那个的，但如果在入队时，把相同值的也删了，那么这个时候就只有删除新入队的这个了，但其实这个新入队的说不定还会是后面一些滑动窗口的最大值。

比如`nums = [-7, -8, 7, 5, 7, 1, 6, 0], k = 4`当滑动窗口移到以第二个7为尾元素时，即`sliding window = [-8, 7, 5, 7]`，此时本来`deque = [7, 5]`,在加入这个元素后，`deque' = [7]`,在下一个滑动窗口`sliding window = [7, 5, 7, 1]`就会被弹出了，但其实他应该能撑到最后一个滑动窗口`sliding window = [7, 1, 6, 0]`。

### 代码
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i) {
            while (dq.size() && nums[i] > dq.back()) {
                dq.pop_back();
            }
            dq.push_back(nums[i]);
            if (i >= k - 1) {
                ans.push_back(dq.front());
                if (dq.front() == nums[i - k + 1]) {
                    dq.pop_front();
                }
            }
        }
        return ans;
    }
};
```
### 结果
![method 2](./results/Offer59-I-2.png)

## 3. 优化后的代码
看了一下，感觉和方法二差不多。
